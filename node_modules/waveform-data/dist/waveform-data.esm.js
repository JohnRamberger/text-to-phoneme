/**
 * Provides access to the waveform data for a single audio channel.
 */
function WaveformDataChannel(waveformData, channelIndex) {
  this._waveformData = waveformData;
  this._channelIndex = channelIndex;
}
/**
 * Returns the waveform minimum at the given index position.
 */


WaveformDataChannel.prototype.min_sample = function (index) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;
  return this._waveformData._at(offset);
};
/**
 * Returns the waveform maximum at the given index position.
 */


WaveformDataChannel.prototype.max_sample = function (index) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;
  return this._waveformData._at(offset);
};
/**
 * Sets the waveform minimum at the given index position.
 */


WaveformDataChannel.prototype.set_min_sample = function (index, sample) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;
  return this._waveformData._set_at(offset, sample);
};
/**
 * Sets the waveform maximum at the given index position.
 */


WaveformDataChannel.prototype.set_max_sample = function (index, sample) {
  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;
  return this._waveformData._set_at(offset, sample);
};
/**
 * Returns all the waveform minimum values as an array.
 */


WaveformDataChannel.prototype.min_array = function () {
  return this._waveformData._offsetValues(0, this._waveformData.length, this._channelIndex * 2);
};
/**
 * Returns all the waveform maximum values as an array.
 */


WaveformDataChannel.prototype.max_array = function () {
  return this._waveformData._offsetValues(0, this._waveformData.length, this._channelIndex * 2 + 1);
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var WORKER_ENABLED = !!(commonjsGlobal === commonjsGlobal.window && commonjsGlobal.URL && commonjsGlobal.Blob && commonjsGlobal.Worker);

function InlineWorker(func, self) {
  var _this = this;

  var functionBody;
  self = self || {};

  if (WORKER_ENABLED) {
    functionBody = func.toString().trim().match(/^function\s*\w*\s*\([\w\s,]*\)\s*{([\w\W]*?)}$/)[1];
    return new commonjsGlobal.Worker(commonjsGlobal.URL.createObjectURL(new commonjsGlobal.Blob([functionBody], {
      type: "text/javascript"
    })));
  }

  function postMessage(data) {
    setTimeout(function () {
      _this.onmessage({
        data: data
      });
    }, 0);
  }

  this.self = self;
  this.self.postMessage = postMessage;
  setTimeout(func.bind(self, self), 0);
}

InlineWorker.prototype.postMessage = function postMessage(data) {
  var _this = this;

  setTimeout(function () {
    _this.self.onmessage({
      data: data
    });
  }, 0);
};

var inlineWorker = InlineWorker;

function MainThreadWorker(func) {
  this._listeners = {};
  func.call(this);
}

MainThreadWorker.prototype.addEventListener = function (event, listener) {
  if (!this._listeners[event]) {
    this._listeners[event] = [];
  }

  this._listeners[event].push(listener);
};

MainThreadWorker.prototype.removeEventListener = function (event, listener) {
  if (this._listeners[event]) {
    this._listeners[event] = this._listeners[event].filter(function (item) {
      return item !== listener;
    });
  }
};

MainThreadWorker.prototype.postMessage = function (data) {
  var event = {
    data: data
  };
  var listeners = this._listeners.message;

  for (var i = 0; i < listeners.length; i++) {
    listeners[i].call(this, event);
  }
};

MainThreadWorker.prototype.close = function () {
  this._listeners = {};
};

/**
 * AudioBuffer-based WaveformData generator
 *
 * Adapted from BlockFile::CalcSummary in Audacity, with permission.
 * See https://code.google.com/p/audacity/source/browse/audacity-src/trunk/src/BlockFile.cpp
 */

function processWorker(workerArgs, callback) {
  var WaveformWorker = workerArgs.disable_worker ? MainThreadWorker : inlineWorker;
  var worker = new WaveformWorker(function () {
    var INT8_MAX = 127;
    var INT8_MIN = -128;

    function calculateWaveformDataLength(audio_sample_count, scale) {
      var data_length = Math.floor(audio_sample_count / scale);
      var samples_remaining = audio_sample_count - data_length * scale;

      if (samples_remaining > 0) {
        data_length++;
      }

      return data_length;
    }

    this.addEventListener("message", function listener(evt) {
      if (!evt.data.audio_buffer) {
        return;
      }

      var scale = evt.data.scale;
      var amplitude_scale = evt.data.amplitude_scale;
      var split_channels = evt.data.split_channels;
      var audio_buffer = evt.data.audio_buffer;
      var channels = audio_buffer.channels;
      var output_channels = split_channels ? channels.length : 1;
      var version = output_channels === 1 ? 1 : 2;
      var header_size = version === 1 ? 20 : 24;
      var data_length = calculateWaveformDataLength(audio_buffer.length, scale);
      var total_size = header_size + data_length * 2 * output_channels;
      var buffer = new ArrayBuffer(total_size);
      var data_view = new DataView(buffer);
      var scale_counter = 0;
      var buffer_length = audio_buffer.length;
      var offset = header_size;
      var channel, i;
      var min_value = new Array(output_channels);
      var max_value = new Array(output_channels);

      for (channel = 0; channel < output_channels; channel++) {
        min_value[channel] = Infinity;
        max_value[channel] = -Infinity;
      }

      data_view.setInt32(0, version, true); // Version

      data_view.setUint32(4, 1, true); // Is 8 bit?

      data_view.setInt32(8, audio_buffer.sampleRate, true); // Sample rate

      data_view.setInt32(12, scale, true); // Scale

      data_view.setInt32(16, data_length, true); // Length

      if (version === 2) {
        data_view.setInt32(20, output_channels, true);
      }

      for (i = 0; i < buffer_length; i++) {
        var sample = 0;

        if (output_channels === 1) {
          for (channel = 0; channel < channels.length; ++channel) {
            sample += channels[channel][i];
          }

          sample = Math.floor(INT8_MAX * sample * amplitude_scale / channels.length);

          if (sample < min_value[0]) {
            min_value[0] = sample;

            if (min_value[0] < INT8_MIN) {
              min_value[0] = INT8_MIN;
            }
          }

          if (sample > max_value[0]) {
            max_value[0] = sample;

            if (max_value[0] > INT8_MAX) {
              max_value[0] = INT8_MAX;
            }
          }
        } else {
          for (channel = 0; channel < output_channels; ++channel) {
            sample = Math.floor(INT8_MAX * channels[channel][i] * amplitude_scale);

            if (sample < min_value[channel]) {
              min_value[channel] = sample;

              if (min_value[channel] < INT8_MIN) {
                min_value[channel] = INT8_MIN;
              }
            }

            if (sample > max_value[channel]) {
              max_value[channel] = sample;

              if (max_value[channel] > INT8_MAX) {
                max_value[channel] = INT8_MAX;
              }
            }
          }
        }

        if (++scale_counter === scale) {
          for (channel = 0; channel < output_channels; channel++) {
            data_view.setInt8(offset++, min_value[channel]);
            data_view.setInt8(offset++, max_value[channel]);
            min_value[channel] = Infinity;
            max_value[channel] = -Infinity;
          }

          scale_counter = 0;
        }
      }

      if (scale_counter > 0) {
        for (channel = 0; channel < output_channels; channel++) {
          data_view.setInt8(offset++, min_value[channel]);
          data_view.setInt8(offset++, max_value[channel]);
        }
      } // Transfer buffer to the calling thread


      this.postMessage(buffer, [buffer]);
      this.removeEventListener("message", listener);
      this.close();
    });
  });
  worker.addEventListener("message", function listener(evt) {
    if (evt.data.audio_buffer) {
      return;
    }

    callback(evt.data); // We're only sending a single message to each listener, so
    // remove the callback afterwards to avoid leaks.

    worker.removeEventListener("message", listener);
  });
  worker.postMessage(workerArgs);
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function isJsonWaveformData(data) {
  return data && _typeof(data) === "object" && "sample_rate" in data && "samples_per_pixel" in data && "bits" in data && "length" in data && "data" in data;
}
function isBinaryWaveformData(data) {
  var isCompatible = data && _typeof(data) === "object" && "byteLength" in data;

  if (isCompatible) {
    var view = new DataView(data);
    var version = view.getInt32(0, true);

    if (version !== 1 && version !== 2) {
      throw new TypeError("WaveformData.create(): This waveform data version not supported");
    }
  }

  return isCompatible;
}
function convertJsonToBinary(data) {
  var waveformData = data.data;
  var channels = data.channels || 1;
  var header_size = 24; // version 2

  var bytes_per_sample = data.bits === 8 ? 1 : 2;
  var expected_length = data.length * 2 * channels;

  if (waveformData.length !== expected_length) {
    throw new Error("WaveformData.create(): Length mismatch in JSON waveform data");
  }

  var total_size = header_size + waveformData.length * bytes_per_sample;
  var array_buffer = new ArrayBuffer(total_size);
  var data_object = new DataView(array_buffer);
  data_object.setInt32(0, 2, true); // Version

  data_object.setUint32(4, data.bits === 8, true);
  data_object.setInt32(8, data.sample_rate, true);
  data_object.setInt32(12, data.samples_per_pixel, true);
  data_object.setInt32(16, data.length, true);
  data_object.setInt32(20, channels, true);
  var index = header_size;
  var i;

  if (data.bits === 8) {
    for (i = 0; i < waveformData.length; i++) {
      data_object.setInt8(index++, waveformData[i], true);
    }
  } else {
    for (i = 0; i < waveformData.length; i++) {
      data_object.setInt16(index, waveformData[i], true);
      index += 2;
    }
  }

  return array_buffer;
}

/**
 * Provides access to waveform data.
 */

function WaveformData(data) {
  if (isJsonWaveformData(data)) {
    data = convertJsonToBinary(data);
  }

  if (isBinaryWaveformData(data)) {
    this._data = new DataView(data);
    this._offset = this._version() === 2 ? 24 : 20;
    this._channels = [];

    for (var channel = 0; channel < this.channels; channel++) {
      this._channels[channel] = new WaveformDataChannel(this, channel);
    }
  } else {
    throw new TypeError("WaveformData.create(): Unknown data format");
  }
}

var defaultOptions = {
  scale: 512,
  amplitude_scale: 1.0,
  split_channels: false,
  disable_worker: false
};

function getOptions(options) {
  var opts = {
    scale: options.scale || defaultOptions.scale,
    amplitude_scale: options.amplitude_scale || defaultOptions.amplitude_scale,
    split_channels: options.split_channels || defaultOptions.split_channels,
    disable_worker: options.disable_worker || defaultOptions.disable_worker
  };
  return opts;
}

function createFromAudioBuffer(audio_buffer, options, callback) {
  var audio_buffer_obj = {
    length: audio_buffer.length,
    sampleRate: audio_buffer.sampleRate,
    channels: []
  }; // Fill in the channels data.

  for (var channel = 0; channel < audio_buffer.numberOfChannels; ++channel) {
    audio_buffer_obj.channels[channel] = audio_buffer.getChannelData(channel);
  }

  processWorker({
    scale: options.scale,
    amplitude_scale: options.amplitude_scale,
    split_channels: options.split_channels,
    audio_buffer: audio_buffer_obj,
    disable_worker: options.disable_worker
  }, function (waveform_data) {
    callback(null, new WaveformData(waveform_data), audio_buffer);
  });
}

function createFromArrayBuffer(audioContext, audioData, options, callback) {
  // The following function is a workaround for a Webkit bug where decodeAudioData
  // invokes the errorCallback with null instead of a DOMException.
  // See https://webaudio.github.io/web-audio-api/#dom-baseaudiocontext-decodeaudiodata
  // and http://stackoverflow.com/q/10365335/103396
  function errorCallback(error) {
    if (!error) {
      error = new DOMException("EncodingError");
    }

    callback(error);
  }

  audioContext.decodeAudioData(audioData, function (audio_buffer) {
    createFromAudioBuffer(audio_buffer, options, callback);
  }, errorCallback);
}
/**
 * Creates and returns a WaveformData instance from the given waveform data.
 */


WaveformData.create = function create(data) {
  return new WaveformData(data);
};
/**
 * Creates a WaveformData instance from audio.
 */


WaveformData.createFromAudio = function (options, callback) {
  var opts = getOptions(options);

  if (options.audio_context && options.array_buffer) {
    return createFromArrayBuffer(options.audio_context, options.array_buffer, opts, callback);
  } else if (options.audio_buffer) {
    return createFromAudioBuffer(options.audio_buffer, opts, callback);
  } else {
    throw new TypeError( // eslint-disable-next-line
    "WaveformData.createFromAudio(): Pass either an AudioContext and ArrayBuffer, or an AudioBuffer object");
  }
};

WaveformData.prototype = {
  /**
   * Creates and returns a new WaveformData object with resampled data.
   * Use this method to create waveform data at different zoom levels.
   *
   * Adapted from Sequence::GetWaveDisplay in Audacity, with permission.
   * https://code.google.com/p/audacity/source/browse/audacity-src/trunk/src/Sequence.cpp
   */
  resample: function resample(options) {
    options.scale = typeof options.scale === "number" ? options.scale : null;
    options.width = typeof options.width === "number" ? options.width : null;

    if (options.width != null && options.width <= 0) {
      throw new RangeError("WaveformData.resample(): width should be a positive integer value");
    }

    if (options.scale != null && options.scale <= 0) {
      throw new RangeError("WaveformData.resample(): scale should be a positive integer value");
    }

    if (!options.scale && !options.width) {
      throw new Error("WaveformData.resample(): Missing scale or width option");
    } // Scale we want to reach


    var output_samples_per_pixel = options.scale || Math.floor(this.duration * this.sample_rate / options.width);
    var scale = this.scale; // scale we are coming from
    // The amount of data we want to resample i.e. final zoom want to resample
    // all data but for intermediate zoom we want to resample subset

    var input_buffer_size = this.length;
    var input_buffer_length_samples = input_buffer_size * this.scale;
    var output_buffer_length_samples = Math.ceil(input_buffer_length_samples / output_samples_per_pixel);
    var output_header_size = 24; // version 2

    var bytes_per_sample = this.bits === 8 ? 1 : 2;
    var total_size = output_header_size + output_buffer_length_samples * 2 * this.channels * bytes_per_sample;
    var output_data = new ArrayBuffer(total_size);
    var output_dataview = new DataView(output_data);
    output_dataview.setInt32(0, 2, true); // Version

    output_dataview.setUint32(4, this.bits === 8, true); // Is 8 bit?

    output_dataview.setInt32(8, this.sample_rate, true);
    output_dataview.setInt32(12, output_samples_per_pixel, true);
    output_dataview.setInt32(16, output_buffer_length_samples, true);
    output_dataview.setInt32(20, this.channels, true);
    var waveform_data = new WaveformData(output_data);
    var input_index = 0;
    var output_index = 0;
    var channels = this.channels;
    var min = new Array(channels);
    var max = new Array(channels);
    var channel;

    for (channel = 0; channel < channels; ++channel) {
      if (input_buffer_size > 0) {
        min[channel] = this.channel(channel).min_sample(input_index);
        max[channel] = this.channel(channel).max_sample(input_index);
      } else {
        min[channel] = 0;
        max[channel] = 0;
      }
    }

    var min_value = this.bits === 8 ? -128 : -32768;
    var max_value = this.bits === 8 ? 127 : 32767;

    if (output_samples_per_pixel < scale) {
      throw new Error("WaveformData.resample(): Zoom level " + output_samples_per_pixel + " too low, minimum: " + scale);
    }

    var where, prev_where, stop, value, last_input_index;

    function sample_at_pixel(x) {
      return Math.floor(x * output_samples_per_pixel);
    }

    while (input_index < input_buffer_size) {
      while (Math.floor(sample_at_pixel(output_index) / scale) === input_index) {
        if (output_index > 0) {
          for (channel = 0; channel < channels; ++channel) {
            waveform_data.channel(channel).set_min_sample(output_index - 1, min[channel]);
            waveform_data.channel(channel).set_max_sample(output_index - 1, max[channel]);
          }
        }

        last_input_index = input_index;
        output_index++;
        where = sample_at_pixel(output_index);
        prev_where = sample_at_pixel(output_index - 1);

        if (where !== prev_where) {
          for (channel = 0; channel < channels; ++channel) {
            min[channel] = max_value;
            max[channel] = min_value;
          }
        }
      }

      where = sample_at_pixel(output_index);
      stop = Math.floor(where / scale);

      if (stop > input_buffer_size) {
        stop = input_buffer_size;
      }

      while (input_index < stop) {
        for (channel = 0; channel < channels; ++channel) {
          value = this.channel(channel).min_sample(input_index);

          if (value < min[channel]) {
            min[channel] = value;
          }

          value = this.channel(channel).max_sample(input_index);

          if (value > max[channel]) {
            max[channel] = value;
          }
        }

        input_index++;
      }
    }

    if (input_index !== last_input_index) {
      for (channel = 0; channel < channels; ++channel) {
        waveform_data.channel(channel).set_min_sample(output_index - 1, min[channel]);
        waveform_data.channel(channel).set_max_sample(output_index - 1, max[channel]);
      }
    }

    return waveform_data;
  },

  /**
   * Concatenates with one or more other waveforms, returning a new WaveformData object.
   */
  concat: function concat() {
    var self = this;
    var otherWaveforms = Array.prototype.slice.call(arguments); // Check that all the supplied waveforms are compatible

    otherWaveforms.forEach(function (otherWaveform) {
      if (self.channels !== otherWaveform.channels || self.sample_rate !== otherWaveform.sample_rate || self.bits !== otherWaveform.bits || self.scale !== otherWaveform.scale) {
        throw new Error("WaveformData.concat(): Waveforms are incompatible");
      }
    });

    var combinedBuffer = this._concatBuffers.apply(this, otherWaveforms);

    return WaveformData.create(combinedBuffer);
  },

  /**
   * Returns a new ArrayBuffer with the concatenated waveform.
   * All waveforms must have identical metadata (version, channels, etc)
   */
  _concatBuffers: function _concatBuffers() {
    var otherWaveforms = Array.prototype.slice.call(arguments);
    var headerSize = this._offset;
    var totalSize = headerSize;
    var totalDataLength = 0;
    var bufferCollection = [this].concat(otherWaveforms).map(function (w) {
      return w._data.buffer;
    });
    var i, buffer;

    for (i = 0; i < bufferCollection.length; i++) {
      buffer = bufferCollection[i];
      var dataSize = new DataView(buffer).getInt32(16, true);
      totalSize += buffer.byteLength - headerSize;
      totalDataLength += dataSize;
    }

    var totalBuffer = new ArrayBuffer(totalSize);
    var sourceHeader = new DataView(bufferCollection[0]);
    var totalBufferView = new DataView(totalBuffer); // Copy the header from the first chunk

    for (i = 0; i < headerSize; i++) {
      totalBufferView.setUint8(i, sourceHeader.getUint8(i));
    } // Rewrite the data-length header item to reflect all of the samples concatenated together


    totalBufferView.setInt32(16, totalDataLength, true);
    var offset = 0;
    var dataOfTotalBuffer = new Uint8Array(totalBuffer, headerSize);

    for (i = 0; i < bufferCollection.length; i++) {
      buffer = bufferCollection[i];
      dataOfTotalBuffer.set(new Uint8Array(buffer, headerSize), offset);
      offset += buffer.byteLength - headerSize;
    }

    return totalBuffer;
  },

  /**
   * Return the unpacked values for a particular offset.
   */
  _offsetValues: function getOffsetValues(start, length, correction) {
    var values = [];
    var channels = this.channels;
    correction += start * channels * 2; // offset the positioning query

    for (var i = 0; i < length; i++) {
      values.push(this._at(i * channels * 2 + correction));
    }

    return values;
  },

  /**
   * Returns the data format version number.
   */
  _version: function _version() {
    return this._data.getInt32(0, true);
  },

  /**
   * Returns the length of the waveform, in pixels.
   */
  get length() {
    return this._data.getUint32(16, true);
  },

  /**
   * Returns the number of bits per sample, either 8 or 16.
   */
  get bits() {
    var bits = Boolean(this._data.getUint32(4, true));
    return bits ? 8 : 16;
  },

  /**
   * Returns the (approximate) duration of the audio file, in seconds.
   */
  get duration() {
    return this.length * this.scale / this.sample_rate;
  },

  /**
   * Returns the number of pixels per second.
   */
  get pixels_per_second() {
    return this.sample_rate / this.scale;
  },

  /**
   * Returns the amount of time represented by a single pixel, in seconds.
   */
  get seconds_per_pixel() {
    return this.scale / this.sample_rate;
  },

  /**
   * Returns the number of waveform channels.
   */
  get channels() {
    if (this._version() === 2) {
      return this._data.getInt32(20, true);
    } else {
      return 1;
    }
  },

  /**
   * Returns a waveform channel.
   */
  channel: function channel(index) {
    if (index >= 0 && index < this._channels.length) {
      return this._channels[index];
    } else {
      throw new RangeError("Invalid channel: " + index);
    }
  },

  /**
   * Returns the number of audio samples per second.
   */
  get sample_rate() {
    return this._data.getInt32(8, true);
  },

  /**
   * Returns the number of audio samples per pixel.
   */
  get scale() {
    return this._data.getInt32(12, true);
  },

  /**
   * Returns a waveform data value at a specific offset.
   */
  _at: function at_sample(index) {
    if (this.bits === 8) {
      return this._data.getInt8(this._offset + index);
    } else {
      return this._data.getInt16(this._offset + index * 2, true);
    }
  },

  /**
   * Sets a waveform data value at a specific offset.
   */
  _set_at: function set_at(index, sample) {
    if (this.bits === 8) {
      return this._data.setInt8(this._offset + index, sample);
    } else {
      return this._data.setInt16(this._offset + index * 2, sample, true);
    }
  },

  /**
   * Returns the waveform data index position for a given time.
   */
  at_time: function at_time(time) {
    return Math.floor(time * this.sample_rate / this.scale);
  },

  /**
   * Returns the time in seconds for a given index.
   */
  time: function time(index) {
    return index * this.scale / this.sample_rate;
  },

  /**
   * Returns an object containing the waveform data.
   */
  toJSON: function toJSON() {
    var waveform = {
      version: 2,
      channels: this.channels,
      sample_rate: this.sample_rate,
      samples_per_pixel: this.scale,
      bits: this.bits,
      length: this.length,
      data: []
    };

    for (var i = 0; i < this.length; i++) {
      for (var channel = 0; channel < this.channels; channel++) {
        waveform.data.push(this.channel(channel).min_sample(i));
        waveform.data.push(this.channel(channel).max_sample(i));
      }
    }

    return waveform;
  },

  /**
   * Returns the waveform data in binary format as an ArrayBuffer.
   */
  toArrayBuffer: function toArrayBuffer() {
    return this._data.buffer;
  }
};

export { WaveformData as default };
