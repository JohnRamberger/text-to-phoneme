{"version":3,"file":"waveform-data.min.js","sources":["../src/waveform-data-channel.js","../node_modules/inline-worker/index.js","../src/util/main-thread-worker.js","../src/builders/audiodecoder.js","../src/waveform-data.js","../src/waveform-utils.js"],"sourcesContent":["/**\n * Provides access to the waveform data for a single audio channel.\n */\n\nfunction WaveformDataChannel(waveformData, channelIndex) {\n  this._waveformData = waveformData;\n  this._channelIndex = channelIndex;\n}\n\n/**\n * Returns the waveform minimum at the given index position.\n */\n\nWaveformDataChannel.prototype.min_sample = function(index) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;\n\n  return this._waveformData._at(offset);\n};\n\n/**\n * Returns the waveform maximum at the given index position.\n */\n\nWaveformDataChannel.prototype.max_sample = function(index) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;\n\n  return this._waveformData._at(offset);\n};\n\n/**\n * Sets the waveform minimum at the given index position.\n */\n\nWaveformDataChannel.prototype.set_min_sample = function(index, sample) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2;\n\n  return this._waveformData._set_at(offset, sample);\n};\n\n/**\n * Sets the waveform maximum at the given index position.\n */\n\nWaveformDataChannel.prototype.set_max_sample = function(index, sample) {\n  var offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;\n\n  return this._waveformData._set_at(offset, sample);\n};\n\n/**\n * Returns all the waveform minimum values as an array.\n */\n\nWaveformDataChannel.prototype.min_array = function() {\n  return this._waveformData._offsetValues(\n    0,\n    this._waveformData.length,\n    this._channelIndex * 2\n  );\n};\n\n/**\n * Returns all the waveform maximum values as an array.\n */\n\nWaveformDataChannel.prototype.max_array = function() {\n  return this._waveformData._offsetValues(\n    0,\n    this._waveformData.length,\n    this._channelIndex * 2 + 1\n  );\n};\n\nexport default WaveformDataChannel;\n","var WORKER_ENABLED = !!(global === global.window && global.URL && global.Blob && global.Worker);\n\nfunction InlineWorker(func, self) {\n  var _this = this;\n  var functionBody;\n\n  self = self || {};\n\n  if (WORKER_ENABLED) {\n    functionBody = func.toString().trim().match(\n      /^function\\s*\\w*\\s*\\([\\w\\s,]*\\)\\s*{([\\w\\W]*?)}$/\n    )[1];\n\n    return new global.Worker(global.URL.createObjectURL(\n      new global.Blob([ functionBody ], { type: \"text/javascript\" })\n    ));\n  }\n\n  function postMessage(data) {\n    setTimeout(function() {\n      _this.onmessage({ data: data });\n    }, 0);\n  }\n\n  this.self = self;\n  this.self.postMessage = postMessage;\n\n  setTimeout(func.bind(self, self), 0);\n}\n\nInlineWorker.prototype.postMessage = function postMessage(data) {\n  var _this = this;\n\n  setTimeout(function() {\n    _this.self.onmessage({ data: data });\n  }, 0);\n};\n\nmodule.exports = InlineWorker;\n","function MainThreadWorker(func) {\n  this._listeners = {};\n\n  func.call(this);\n}\n\nMainThreadWorker.prototype.addEventListener = function(event, listener) {\n  if (!this._listeners[event]) {\n    this._listeners[event] = [];\n  }\n\n  this._listeners[event].push(listener);\n};\n\nMainThreadWorker.prototype.removeEventListener = function(event, listener) {\n  if (this._listeners[event]) {\n    this._listeners[event] = this._listeners[event].filter(function(item) {\n      return item !== listener;\n    });\n  }\n};\n\nMainThreadWorker.prototype.postMessage = function(data) {\n  var event = { data: data };\n\n  var listeners = this._listeners.message;\n\n  for (var i = 0; i < listeners.length; i++) {\n    listeners[i].call(this, event);\n  }\n};\n\nMainThreadWorker.prototype.close = function() {\n  this._listeners = {};\n};\n\nexport default MainThreadWorker;\n","import InlineWorker from \"inline-worker\";\nimport MainThreadWorker from \"../util/main-thread-worker\";\n\n/**\n * AudioBuffer-based WaveformData generator\n *\n * Adapted from BlockFile::CalcSummary in Audacity, with permission.\n * See https://code.google.com/p/audacity/source/browse/audacity-src/trunk/src/BlockFile.cpp\n */\n\nfunction processWorker(workerArgs, callback) {\n  var WaveformWorker = workerArgs.disable_worker ? MainThreadWorker : InlineWorker;\n\n  var worker = new WaveformWorker(function() {\n    var INT8_MAX = 127;\n    var INT8_MIN = -128;\n\n    function calculateWaveformDataLength(audio_sample_count, scale) {\n      var data_length = Math.floor(audio_sample_count / scale);\n\n      var samples_remaining = audio_sample_count - (data_length * scale);\n\n      if (samples_remaining > 0) {\n        data_length++;\n      }\n\n      return data_length;\n    }\n\n    this.addEventListener(\"message\", function listener(evt) {\n      if (!evt.data.audio_buffer) {\n        return;\n      }\n\n      var scale = evt.data.scale;\n      var amplitude_scale = evt.data.amplitude_scale;\n      var split_channels = evt.data.split_channels;\n      var audio_buffer = evt.data.audio_buffer;\n\n      var channels = audio_buffer.channels;\n      var output_channels = split_channels ? channels.length : 1;\n      var version = output_channels === 1 ? 1 : 2;\n      var header_size = version === 1 ? 20 : 24;\n      var data_length = calculateWaveformDataLength(audio_buffer.length, scale);\n      var total_size = header_size + data_length * 2 * output_channels;\n      var buffer = new ArrayBuffer(total_size);\n      var data_view = new DataView(buffer);\n\n      var scale_counter = 0;\n      var buffer_length = audio_buffer.length;\n      var offset = header_size;\n      var channel, i;\n\n      var min_value = new Array(output_channels);\n      var max_value = new Array(output_channels);\n\n      for (channel = 0; channel < output_channels; channel++) {\n        min_value[channel] = Infinity;\n        max_value[channel] = -Infinity;\n      }\n\n      data_view.setInt32(0, version, true); // Version\n      data_view.setUint32(4, 1, true); // Is 8 bit?\n      data_view.setInt32(8, audio_buffer.sampleRate, true); // Sample rate\n      data_view.setInt32(12, scale, true); // Scale\n      data_view.setInt32(16, data_length, true); // Length\n\n      if (version === 2) {\n        data_view.setInt32(20, output_channels, true);\n      }\n\n      for (i = 0; i < buffer_length; i++) {\n        var sample = 0;\n\n        if (output_channels === 1) {\n          for (channel = 0; channel < channels.length; ++channel) {\n            sample += channels[channel][i];\n          }\n\n          sample = Math.floor(INT8_MAX * sample * amplitude_scale / channels.length);\n\n          if (sample < min_value[0]) {\n            min_value[0] = sample;\n\n            if (min_value[0] < INT8_MIN) {\n              min_value[0] = INT8_MIN;\n            }\n          }\n\n          if (sample > max_value[0]) {\n            max_value[0] = sample;\n\n            if (max_value[0] > INT8_MAX) {\n              max_value[0] = INT8_MAX;\n            }\n          }\n        }\n        else {\n          for (channel = 0; channel < output_channels; ++channel) {\n            sample = Math.floor(INT8_MAX * channels[channel][i] * amplitude_scale);\n\n            if (sample < min_value[channel]) {\n              min_value[channel] = sample;\n\n              if (min_value[channel] < INT8_MIN) {\n                min_value[channel] = INT8_MIN;\n              }\n            }\n\n            if (sample > max_value[channel]) {\n              max_value[channel] = sample;\n\n              if (max_value[channel] > INT8_MAX) {\n                max_value[channel] = INT8_MAX;\n              }\n            }\n          }\n        }\n\n        if (++scale_counter === scale) {\n          for (channel = 0; channel < output_channels; channel++) {\n            data_view.setInt8(offset++, min_value[channel]);\n            data_view.setInt8(offset++, max_value[channel]);\n\n            min_value[channel] = Infinity;\n            max_value[channel] = -Infinity;\n          }\n\n          scale_counter = 0;\n        }\n      }\n\n      if (scale_counter > 0) {\n        for (channel = 0; channel < output_channels; channel++) {\n          data_view.setInt8(offset++, min_value[channel]);\n          data_view.setInt8(offset++, max_value[channel]);\n        }\n      }\n\n      // Transfer buffer to the calling thread\n      this.postMessage(buffer, [buffer]);\n      this.removeEventListener(\"message\", listener);\n      this.close();\n    });\n  });\n\n  worker.addEventListener(\"message\", function listener(evt) {\n    if (evt.data.audio_buffer) {\n      return;\n    }\n\n    callback(evt.data);\n\n    // We're only sending a single message to each listener, so\n    // remove the callback afterwards to avoid leaks.\n    worker.removeEventListener(\"message\", listener);\n  });\n\n  worker.postMessage(workerArgs);\n}\n\nexport default processWorker;\n","\"use strict\";\n\nimport WaveformDataChannel from \"./waveform-data-channel\";\nimport processWorker from \"./builders/audiodecoder\";\nimport { isJsonWaveformData, isBinaryWaveformData, convertJsonToBinary } from \"./waveform-utils\";\n\n/**\n * Provides access to waveform data.\n */\n\nfunction WaveformData(data) {\n  if (isJsonWaveformData(data)) {\n    data = convertJsonToBinary(data);\n  }\n\n  if (isBinaryWaveformData(data)) {\n    this._data = new DataView(data);\n    this._offset = this._version() === 2 ? 24 : 20;\n\n    this._channels = [];\n\n    for (var channel = 0; channel < this.channels; channel++) {\n      this._channels[channel] = new WaveformDataChannel(this, channel);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"WaveformData.create(): Unknown data format\"\n    );\n  }\n}\n\nvar defaultOptions = {\n  scale: 512,\n  amplitude_scale: 1.0,\n  split_channels: false,\n  disable_worker: false\n};\n\nfunction getOptions(options) {\n  var opts = {\n    scale: options.scale || defaultOptions.scale,\n    amplitude_scale: options.amplitude_scale || defaultOptions.amplitude_scale,\n    split_channels: options.split_channels || defaultOptions.split_channels,\n    disable_worker: options.disable_worker || defaultOptions.disable_worker\n  };\n\n  return opts;\n}\n\nfunction createFromAudioBuffer(audio_buffer, options, callback) {\n  var audio_buffer_obj = {\n    length: audio_buffer.length,\n    sampleRate: audio_buffer.sampleRate,\n    channels: []\n  };\n\n  // Fill in the channels data.\n  for (var channel = 0; channel < audio_buffer.numberOfChannels; ++channel) {\n    audio_buffer_obj.channels[channel] = audio_buffer.getChannelData(channel);\n  }\n\n  processWorker({\n    scale: options.scale,\n    amplitude_scale: options.amplitude_scale,\n    split_channels: options.split_channels,\n    audio_buffer: audio_buffer_obj,\n    disable_worker: options.disable_worker\n  },\n  function(waveform_data) {\n    callback(null, new WaveformData(waveform_data), audio_buffer);\n  });\n}\n\nfunction createFromArrayBuffer(audioContext, audioData, options, callback) {\n  // The following function is a workaround for a Webkit bug where decodeAudioData\n  // invokes the errorCallback with null instead of a DOMException.\n  // See https://webaudio.github.io/web-audio-api/#dom-baseaudiocontext-decodeaudiodata\n  // and http://stackoverflow.com/q/10365335/103396\n\n  function errorCallback(error) {\n    if (!error) {\n      error = new DOMException(\"EncodingError\");\n    }\n\n    callback(error);\n  }\n\n  audioContext.decodeAudioData(\n    audioData,\n    function(audio_buffer) {\n      createFromAudioBuffer(audio_buffer, options, callback);\n    },\n    errorCallback\n  );\n}\n\n/**\n * Creates and returns a WaveformData instance from the given waveform data.\n */\n\nWaveformData.create = function create(data) {\n  return new WaveformData(data);\n};\n\n/**\n * Creates a WaveformData instance from audio.\n */\n\nWaveformData.createFromAudio = function(options, callback) {\n  var opts = getOptions(options);\n\n  if (options.audio_context && options.array_buffer) {\n    return createFromArrayBuffer(options.audio_context, options.array_buffer, opts, callback);\n  }\n  else if (options.audio_buffer) {\n    return createFromAudioBuffer(options.audio_buffer, opts, callback);\n  }\n  else {\n    throw new TypeError(\n      // eslint-disable-next-line\n      \"WaveformData.createFromAudio(): Pass either an AudioContext and ArrayBuffer, or an AudioBuffer object\"\n    );\n  }\n};\n\nWaveformData.prototype = {\n\n  /**\n   * Creates and returns a new WaveformData object with resampled data.\n   * Use this method to create waveform data at different zoom levels.\n   *\n   * Adapted from Sequence::GetWaveDisplay in Audacity, with permission.\n   * https://code.google.com/p/audacity/source/browse/audacity-src/trunk/src/Sequence.cpp\n   */\n\n  resample: function(options) {\n    options.scale = typeof options.scale === \"number\" ? options.scale : null;\n    options.width = typeof options.width === \"number\" ? options.width : null;\n\n    if (options.width != null && options.width <= 0) {\n      throw new RangeError(\"WaveformData.resample(): width should be a positive integer value\");\n    }\n\n    if (options.scale != null && options.scale <= 0) {\n      throw new RangeError(\"WaveformData.resample(): scale should be a positive integer value\");\n    }\n\n    if (!options.scale && !options.width) {\n      throw new Error(\"WaveformData.resample(): Missing scale or width option\");\n    }\n\n    // Scale we want to reach\n    var output_samples_per_pixel = options.scale ||\n      Math.floor(this.duration * this.sample_rate / options.width);\n    var scale = this.scale; // scale we are coming from\n\n    // The amount of data we want to resample i.e. final zoom want to resample\n    // all data but for intermediate zoom we want to resample subset\n    var input_buffer_size = this.length;\n\n    var input_buffer_length_samples = input_buffer_size * this.scale;\n    var output_buffer_length_samples =\n      Math.ceil(input_buffer_length_samples / output_samples_per_pixel);\n\n    var output_header_size = 24; // version 2\n    var bytes_per_sample = this.bits === 8 ? 1 : 2;\n    var total_size = output_header_size\n                   + output_buffer_length_samples * 2 * this.channels * bytes_per_sample;\n    var output_data = new ArrayBuffer(total_size);\n    var output_dataview = new DataView(output_data);\n\n    output_dataview.setInt32(0, 2, true); // Version\n    output_dataview.setUint32(4, this.bits === 8, true); // Is 8 bit?\n    output_dataview.setInt32(8, this.sample_rate, true);\n    output_dataview.setInt32(12, output_samples_per_pixel, true);\n    output_dataview.setInt32(16, output_buffer_length_samples, true);\n    output_dataview.setInt32(20, this.channels, true);\n\n    var waveform_data = new WaveformData(output_data);\n\n    var input_index = 0;\n    var output_index = 0;\n\n    var channels = this.channels;\n\n    var min = new Array(channels);\n    var max = new Array(channels);\n\n    var channel;\n\n    for (channel = 0; channel < channels; ++channel) {\n      if (input_buffer_size > 0) {\n        min[channel] = this.channel(channel).min_sample(input_index);\n        max[channel] = this.channel(channel).max_sample(input_index);\n      }\n      else {\n        min[channel] = 0;\n        max[channel] = 0;\n      }\n    }\n\n    var min_value = this.bits === 8 ? -128 : -32768;\n    var max_value = this.bits === 8 ?  127 :  32767;\n\n    if (output_samples_per_pixel < scale) {\n      throw new Error(\n        \"WaveformData.resample(): Zoom level \" + output_samples_per_pixel +\n        \" too low, minimum: \" + scale\n      );\n    }\n\n    var where, prev_where, stop, value, last_input_index;\n\n    function sample_at_pixel(x) {\n      return Math.floor(x * output_samples_per_pixel);\n    }\n\n    while (input_index < input_buffer_size) {\n      while (Math.floor(sample_at_pixel(output_index) / scale) === input_index) {\n        if (output_index > 0) {\n          for (channel = 0; channel < channels; ++channel) {\n            waveform_data.channel(channel).set_min_sample(output_index - 1, min[channel]);\n            waveform_data.channel(channel).set_max_sample(output_index - 1, max[channel]);\n          }\n        }\n\n        last_input_index = input_index;\n\n        output_index++;\n\n        where      = sample_at_pixel(output_index);\n        prev_where = sample_at_pixel(output_index - 1);\n\n        if (where !== prev_where) {\n          for (channel = 0; channel < channels; ++channel) {\n            min[channel] = max_value;\n            max[channel] = min_value;\n          }\n        }\n      }\n\n      where = sample_at_pixel(output_index);\n      stop = Math.floor(where / scale);\n\n      if (stop > input_buffer_size) {\n        stop = input_buffer_size;\n      }\n\n      while (input_index < stop) {\n        for (channel = 0; channel < channels; ++channel) {\n          value = this.channel(channel).min_sample(input_index);\n\n          if (value < min[channel]) {\n            min[channel] = value;\n          }\n\n          value = this.channel(channel).max_sample(input_index);\n\n          if (value > max[channel]) {\n            max[channel] = value;\n          }\n        }\n\n        input_index++;\n      }\n    }\n\n    if (input_index !== last_input_index) {\n      for (channel = 0; channel < channels; ++channel) {\n        waveform_data.channel(channel).set_min_sample(output_index - 1, min[channel]);\n        waveform_data.channel(channel).set_max_sample(output_index - 1, max[channel]);\n      }\n    }\n\n    return waveform_data;\n  },\n\n  /**\n   * Concatenates with one or more other waveforms, returning a new WaveformData object.\n   */\n\n  concat: function() {\n    var self = this;\n    var otherWaveforms = Array.prototype.slice.call(arguments);\n\n    // Check that all the supplied waveforms are compatible\n    otherWaveforms.forEach(function(otherWaveform) {\n      if (self.channels !== otherWaveform.channels ||\n        self.sample_rate !== otherWaveform.sample_rate ||\n        self.bits !== otherWaveform.bits ||\n        self.scale !== otherWaveform.scale) {\n        throw new Error(\"WaveformData.concat(): Waveforms are incompatible\");\n      }\n    });\n\n    var combinedBuffer = this._concatBuffers.apply(this, otherWaveforms);\n\n    return WaveformData.create(combinedBuffer);\n  },\n\n  /**\n   * Returns a new ArrayBuffer with the concatenated waveform.\n   * All waveforms must have identical metadata (version, channels, etc)\n   */\n\n  _concatBuffers: function() {\n    var otherWaveforms = Array.prototype.slice.call(arguments);\n    var headerSize = this._offset;\n    var totalSize = headerSize;\n    var totalDataLength = 0;\n    var bufferCollection = [this].concat(otherWaveforms).map(function(w) {\n      return w._data.buffer;\n    });\n    var i, buffer;\n\n    for (i = 0; i < bufferCollection.length; i++) {\n      buffer = bufferCollection[i];\n      var dataSize = new DataView(buffer).getInt32(16, true);\n\n      totalSize += buffer.byteLength - headerSize;\n      totalDataLength += dataSize;\n    }\n\n    var totalBuffer = new ArrayBuffer(totalSize);\n    var sourceHeader = new DataView(bufferCollection[0]);\n    var totalBufferView = new DataView(totalBuffer);\n\n    // Copy the header from the first chunk\n    for (i = 0; i < headerSize; i++) {\n      totalBufferView.setUint8(i, sourceHeader.getUint8(i));\n    }\n    // Rewrite the data-length header item to reflect all of the samples concatenated together\n    totalBufferView.setInt32(16, totalDataLength, true);\n\n    var offset = 0;\n    var dataOfTotalBuffer = new Uint8Array(totalBuffer, headerSize);\n\n    for (i = 0; i < bufferCollection.length; i++) {\n      buffer = bufferCollection[i];\n      dataOfTotalBuffer.set(new Uint8Array(buffer, headerSize), offset);\n      offset += buffer.byteLength - headerSize;\n    }\n\n    return totalBuffer;\n  },\n\n  /**\n   * Return the unpacked values for a particular offset.\n   */\n\n  _offsetValues: function getOffsetValues(start, length, correction) {\n    var values = [];\n    var channels = this.channels;\n\n    correction += (start * channels * 2); // offset the positioning query\n\n    for (var i = 0; i < length; i++) {\n      values.push(this._at((i * channels * 2) + correction));\n    }\n\n    return values;\n  },\n\n  /**\n   * Returns the data format version number.\n   */\n\n  _version: function() {\n    return this._data.getInt32(0, true);\n  },\n\n  /**\n   * Returns the length of the waveform, in pixels.\n   */\n\n  get length() {\n    return this._data.getUint32(16, true);\n  },\n\n  /**\n   * Returns the number of bits per sample, either 8 or 16.\n   */\n\n  get bits() {\n    var bits = Boolean(this._data.getUint32(4, true));\n\n    return bits ? 8 : 16;\n  },\n\n  /**\n   * Returns the (approximate) duration of the audio file, in seconds.\n   */\n\n  get duration() {\n    return this.length * this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns the number of pixels per second.\n   */\n\n  get pixels_per_second() {\n    return this.sample_rate / this.scale;\n  },\n\n  /**\n   * Returns the amount of time represented by a single pixel, in seconds.\n   */\n\n  get seconds_per_pixel() {\n    return this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns the number of waveform channels.\n   */\n\n  get channels() {\n    if (this._version() === 2) {\n      return this._data.getInt32(20, true);\n    }\n    else {\n      return 1;\n    }\n  },\n\n  /**\n   * Returns a waveform channel.\n   */\n\n  channel: function(index) {\n    if (index >= 0 && index < this._channels.length) {\n      return this._channels[index];\n    }\n    else {\n      throw new RangeError(\"Invalid channel: \" + index);\n    }\n  },\n\n  /**\n   * Returns the number of audio samples per second.\n   */\n\n  get sample_rate() {\n    return this._data.getInt32(8, true);\n  },\n\n  /**\n   * Returns the number of audio samples per pixel.\n   */\n\n  get scale() {\n    return this._data.getInt32(12, true);\n  },\n\n  /**\n   * Returns a waveform data value at a specific offset.\n   */\n\n  _at: function at_sample(index) {\n    if (this.bits === 8) {\n      return this._data.getInt8(this._offset + index);\n    }\n    else {\n      return this._data.getInt16(this._offset + index * 2, true);\n    }\n  },\n\n  /**\n   * Sets a waveform data value at a specific offset.\n   */\n\n  _set_at: function set_at(index, sample) {\n    if (this.bits === 8) {\n      return this._data.setInt8(this._offset + index, sample);\n    }\n    else {\n      return this._data.setInt16(this._offset + index * 2, sample, true);\n    }\n  },\n\n  /**\n   * Returns the waveform data index position for a given time.\n   */\n\n  at_time: function at_time(time) {\n    return Math.floor(time * this.sample_rate / this.scale);\n  },\n\n  /**\n   * Returns the time in seconds for a given index.\n   */\n\n  time: function time(index) {\n    return index * this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns an object containing the waveform data.\n   */\n\n  toJSON: function() {\n    const waveform = {\n      version: 2,\n      channels: this.channels,\n      sample_rate: this.sample_rate,\n      samples_per_pixel: this.scale,\n      bits: this.bits,\n      length: this.length,\n      data: []\n    };\n\n    for (var i = 0; i < this.length; i++) {\n      for (var channel = 0; channel < this.channels; channel++) {\n        waveform.data.push(this.channel(channel).min_sample(i));\n        waveform.data.push(this.channel(channel).max_sample(i));\n      }\n    }\n\n    return waveform;\n  },\n\n  /**\n   * Returns the waveform data in binary format as an ArrayBuffer.\n   */\n\n  toArrayBuffer: function() {\n    return this._data.buffer;\n  }\n};\n\nexport default WaveformData;\n","export function isJsonWaveformData(data) {\n  return data &&\n    typeof data === \"object\" &&\n    \"sample_rate\" in data &&\n    \"samples_per_pixel\" in data &&\n    \"bits\" in data &&\n    \"length\" in data &&\n    \"data\" in data;\n}\n\nexport function isBinaryWaveformData(data) {\n  var isCompatible = data && typeof data === \"object\" && \"byteLength\" in data;\n\n  if (isCompatible) {\n    var view = new DataView(data);\n    var version = view.getInt32(0, true);\n\n    if (version !== 1 && version !== 2) {\n      throw new TypeError(\"WaveformData.create(): This waveform data version not supported\");\n    }\n  }\n\n  return isCompatible;\n}\n\nexport function convertJsonToBinary(data) {\n  var waveformData = data.data;\n  var channels = data.channels || 1;\n  var header_size = 24; // version 2\n  var bytes_per_sample = data.bits === 8 ? 1 : 2;\n  var expected_length = data.length * 2 * channels;\n\n  if (waveformData.length !== expected_length) {\n    throw new Error(\"WaveformData.create(): Length mismatch in JSON waveform data\");\n  }\n\n  var total_size = header_size + waveformData.length * bytes_per_sample;\n\n  var array_buffer = new ArrayBuffer(total_size);\n  var data_object = new DataView(array_buffer);\n\n  data_object.setInt32(0, 2, true); // Version\n  data_object.setUint32(4, data.bits === 8, true);\n  data_object.setInt32(8, data.sample_rate, true);\n  data_object.setInt32(12, data.samples_per_pixel, true);\n  data_object.setInt32(16, data.length, true);\n  data_object.setInt32(20, channels, true);\n\n  var index = header_size;\n\n  var i;\n\n  if (data.bits === 8) {\n    for (i = 0; i < waveformData.length; i++) {\n      data_object.setInt8(index++, waveformData[i], true);\n    }\n  }\n  else {\n    for (i = 0; i < waveformData.length; i++) {\n      data_object.setInt16(index, waveformData[i], true);\n\n      index += 2;\n    }\n  }\n\n  return array_buffer;\n}\n"],"names":["WaveformDataChannel","waveformData","channelIndex","_waveformData","_channelIndex","prototype","min_sample","index","offset","this","channels","_at","max_sample","set_min_sample","sample","_set_at","set_max_sample","min_array","_offsetValues","length","max_array","WORKER_ENABLED","global","window","URL","Blob","Worker","InlineWorker","func","self","functionBody","_this","toString","trim","match","createObjectURL","type","postMessage","data","setTimeout","onmessage","bind","inlineWorker","MainThreadWorker","_listeners","call","processWorker","workerArgs","callback","worker","disable_worker","INT8_MAX","INT8_MIN","addEventListener","listener","evt","audio_buffer","channel","i","scale","amplitude_scale","split_channels","output_channels","version","header_size","data_length","audio_sample_count","Math","floor","calculateWaveformDataLength","buffer","ArrayBuffer","data_view","DataView","scale_counter","buffer_length","min_value","Array","max_value","Infinity","setInt32","setUint32","sampleRate","setInt8","removeEventListener","close","WaveformData","_typeof","isJsonWaveformData","bytes_per_sample","bits","expected_length","Error","total_size","array_buffer","data_object","sample_rate","samples_per_pixel","setInt16","convertJsonToBinary","isCompatible","getInt32","TypeError","isBinaryWaveformData","_data","_offset","_version","_channels","event","push","filter","item","listeners","message","defaultOptions","createFromAudioBuffer","options","audio_buffer_obj","numberOfChannels","getChannelData","waveform_data","create","createFromAudio","opts","getOptions","audio_context","audioContext","audioData","decodeAudioData","error","DOMException","createFromArrayBuffer","resample","width","RangeError","output_samples_per_pixel","duration","input_buffer_size","input_buffer_length_samples","output_buffer_length_samples","ceil","output_data","output_dataview","input_index","output_index","min","max","where","stop","value","last_input_index","sample_at_pixel","x","concat","otherWaveforms","slice","arguments","forEach","otherWaveform","combinedBuffer","_concatBuffers","apply","headerSize","totalSize","totalDataLength","bufferCollection","map","w","dataSize","byteLength","totalBuffer","sourceHeader","totalBufferView","setUint8","getUint8","dataOfTotalBuffer","Uint8Array","set","start","correction","values","getUint32","Boolean","pixels_per_second","seconds_per_pixel","getInt8","getInt16","at_time","time","toJSON","waveform","toArrayBuffer"],"mappings":"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"}